# Lynis and OpenSCAP: Leveraging SSH for Secure Transmission

This README outlines how Lynis and OpenSCAP, two powerful security tools, interact with SSH to ensure secure auditing and remote system scanning. While both contribute to system security, their use of SSH differs significantly.

## Lynis: Auditing SSH Configuration for Secure Hardening

Lynis is an open-source, battle-tested security auditing and hardening tool for Unix-based systems. Its primary function regarding SSH is to **audit and provide recommendations for hardening the SSH configuration** on the *local* system where Lynis is executed.

Lynis performs a comprehensive scan of the system, including checks on the SSH daemon configuration (`sshd_config`). It identifies potential weaknesses and offers suggestions to improve SSH security. These checks include, but are not limited to:

*   **SSH Configuration Hardening (SSH-7408):** Lynis assesses various SSH configuration options to ensure they adhere to security best practices. This involves checking for strong ciphers, key exchange algorithms, and MACs, as well as disabling insecure features.
*   **Permit Root Login (SSH-7412):** It warns against allowing direct root logins via SSH, recommending the use of a non-root user with `sudo` for traceability and reduced risk.
*   **StrictModes Option (SSH-7416):** Lynis verifies that `StrictModes` is enabled in the SSH configuration, which ensures that SSH checks file permissions on user home directories and key files before accepting connections, preventing unauthorized access due to lax permissions.

**How Lynis works with SSH for secure interaction (user-initiated remote execution):**
While Lynis is fundamentally a local auditing tool, its results are often critical for remote systems. Users commonly interact with Lynis on remote machines by establishing a secure SSH connection to that machine. In this scenario, SSH provides the encrypted tunnel for:

*   **Secure Command Transmission:** The user's commands to run Lynis (e.g., `ssh user@remote_host 'sudo lynis audit system'`) are securely transmitted to the remote server over the SSH encrypted tunnel.
*   **Secure Output Reception:** The audit results and reports generated by Lynis on the remote system are then securely transmitted back to the user's local terminal via the same SSH encrypted channel.

Lynis's direct role regarding SSH focuses on **auditing and recommending hardening for the *local SSH daemon's configuration* (`sshd_config`)** on the system it runs on. It ensures that the SSH service itself is configured securely (e.g., strong ciphers, disabled root login, `StrictModes`), which contributes to the overall secure transmission of any data flowing through that SSH service, including the user's interactive session with Lynis.

## OpenSCAP: Secure Remote Scanning via `oscap-ssh`

OpenSCAP is an open-source implementation of the Security Content Automation Protocol (SCAP), a suite of security standards. Unlike Lynis's primary focus on local auditing, OpenSCAP, through its `oscap-ssh` utility, **actively leverages SSH for secure remote scanning and data transmission** between a local (auditor) machine and a remote (target) machine.

The `oscap-ssh` utility facilitates a secure and automated way to perform compliance checks and vulnerability assessments on remote systems without needing to directly install OpenSCAP on every target.

**How OpenSCAP uses SSH for secure transmission:**

1.  **Secure Content Transfer:** `oscap-ssh` utilizes SSH (specifically SCP, Secure Copy Protocol, which runs over SSH) to securely transfer the SCAP content (e.g., security guides, OVAL definitions, XCCDF benchmarks) from the local machine to a temporary directory on the remote target system. This ensures the integrity and confidentiality of the security policies being applied.

2.  **Secure Remote Execution:** Once the content is on the remote machine, `oscap-ssh` remotely executes the `oscap` command on the target system via the established SSH tunnel. This command performs the actual security evaluation against the transferred SCAP content.

3.  **Secure Results Retrieval:** After the scan is complete, `oscap-ssh` uses SCP again to securely copy the generated results (such as HTML reports, XCCDF results, and ARF files) back from the remote machine to the local auditing machine. This protects sensitive audit findings during transit.

4.  **Authentication and Authorization:** `oscap-ssh` supports standard SSH authentication methods. While password-based authentication is an option, it is generally recommended to use **public-key authentication** for enhanced security. With public-key authentication, a pair of cryptographic keys (a public key and a private key) is used. The public key is stored on the remote server, and the private key is kept securely on the local machine. When connecting, the remote server challenges the client to prove possession of the private key, without ever transmitting the private key itself. The SHA (Secure Hash Algorithm) in this context often refers to the **SSH key fingerprint**, which is a concise representation of the public key, used to verify the key's authenticity and prevent man-in-the-middle attacks. It's recommended to configure a non-root user with `sudo` privileges on the remote system for the scan, enhancing security by avoiding direct root logins.

In summary, OpenSCAP's `oscap-ssh` is designed to provide end-to-end secure communication for remote scanning, ensuring that both the security content and the audit results are transmitted and processed confidentially and with integrity over SSH.

---

Both Lynis and OpenSCAP are valuable tools in a robust security strategy. Lynis helps harden individual system configurations, including SSH, from within, while OpenSCAP extends auditing capabilities to remote systems securely via SSH for comprehensive compliance and vulnerability management.

# SSH Authentication in Wazuh-Isolated: Connecting to Remote Systems

This document explains the various SSH authentication methods available in the Wazuh-Isolated application for connecting to remote systems, primarily for Lynis and OpenSCAP operations. Understanding these methods is crucial for ensuring secure and efficient remote management.

## Overview of SSH Authentication Methods

SSH (Secure Shell) is a cryptographic network protocol for operating network services securely over an unsecured network. It provides a secure channel over an unsecured network by using a client-server architecture, connecting an SSH client with an SSH server.

Our application supports the following SSH authentication types for connecting to your remote targets:

1.  **Password-Based Authentication:** The traditional method requiring a username and password.
2.  **Public Key Authentication:** A more secure method using a pair of cryptographic keys.
    *   **Pasting Private Key Content:** For users who already possess an SSH key pair.
    *   **Generate & Deploy New Public Key:** An automated, user-friendly option to create and deploy new keys.

## 1. Password-Based Authentication

This is the most common and straightforward method. When you select "Password" authentication:

*   **How it Works:** You provide the username and password for the remote account. The application sends these credentials over the encrypted SSH tunnel to the remote server, which then verifies them against its user database.
*   **Security Considerations:** While convenient, password-based authentication is generally considered less secure than public key authentication. It is susceptible to brute-force attacks if weak passwords are used, and there's a theoretical risk of interception if the initial key exchange (which establishes the encryption) is compromised (though SSH's key exchange is robust).
*   **Use Case:** Suitable for quick setups or environments where public key infrastructure is not yet established, but always use strong, unique passwords.

## 2. Public Key Authentication

Public key authentication is the recommended and more secure method for SSH connections. It eliminates the need to transmit a password and relies on cryptographic key pairs.

*   **How it Works (General Concept):**
    *   You have a **private key** (kept secret on your local machine) and a **public key** (which you place on the remote server).
    *   When you attempt to connect, the remote server uses your public key to encrypt a challenge.
    *   Your local SSH client uses your private key to decrypt the challenge and sends back the correct response.
    *   The private key itself is never transmitted, only used for cryptographic proof of identity.
    *   A **passphrase** can be added to your private key for an extra layer of security. This encrypts the private key file on your disk, requiring you to enter the passphrase before the key can be used.
    *   The **SSH key fingerprint (SHA)** is a short hash of the public key, used to verify the key's authenticity and prevent man-in-the-middle attacks when establishing the initial connection.

### Option A: Public Key (paste content)

This option is for users who already have an existing SSH public/private key pair.

*   **How it Works:**
    1.  You generate an SSH key pair (e.g., using `ssh-keygen` on your local machine).
    2.  You manually copy the content of your **private key file** (including `-----BEGIN...` and `-----END...` lines) and paste it into the designated field in the application's SSH configuration modal.
    3.  If your private key is protected by a passphrase, you enter that as well.
    4.  The public key associated with your private key must already be deployed to the `~/.ssh/authorized_keys` file on the remote server.
*   **Security:** Highly secure, as the private key is managed by the user and only its content is provided to the application's backend for establishing connections.

### Option B: Generate & Deploy New Public Key (easiest)

This is an automated feature designed for maximum user-friendliness, especially for new setups.

*   **How it Works:**
    1.  You provide the remote host, port, username, and the **remote user's password (for one-time deployment)**.
    2.  (Optional) You can specify a passphrase for the *new* private key that will be generated.
    3.  When you click "Deploy Key & Configure", the application's backend performs the following steps:
        *   **Key Generation:** A new SSH private and public key pair is securely generated *in-memory* on the backend server.
        *   **Temporary Connection:** The backend uses the provided remote user's password to establish a *temporary SSH connection* to the remote server.
        *   **Public Key Deployment:** Over this temporary secure connection, the backend executes commands on the remote server to:
            *   Create the `~/.ssh` directory if it doesn't exist (`mkdir -p ~/.ssh && chmod 700 ~/.ssh`).
            *   Append the newly generated public key to the `~/.ssh/authorized_keys` file (`echo 'your_public_key' >> ~/.ssh/authorized_keys`).
            *   Set appropriate permissions for the `authorized_keys` file (`chmod 600 ~/.ssh/authorized_keys`).
        *   **Persistent Connection:** Once the public key is successfully deployed, the temporary connection is closed. The application then establishes a new, persistent SSH connection to the remote server using the *newly generated private key* (and its passphrase, if set).
*   **Security:** This method is highly secure *after* the initial deployment. The remote user's password is used only once for the deployment step and is not stored. Subsequent connections rely solely on the generated SSH key pair. The private key is generated and stored securely (in-memory) by the backend for the duration of the session.

## Backend Handling of SSH Connections

The application's backend (`server.js` and `server/services/sshService.js`) intelligently handles the different authentication types:

*   **Dynamic Authentication:** The backend receives the chosen `authType` (password, privateKey, or generateNew) along with the corresponding credentials from the frontend.
*   **`sshService.js`:** This service utilizes a robust `node-ssh` library to establish and manage SSH connections. It dynamically configures the SSH client based on the provided authentication type, using either password, private key content, or orchestrating the key generation and deployment flow.
*   **Secure Credential Handling:** Passwords and private key content are used only for establishing the initial connection or deploying keys and are not persisted in permanent storage within the application (they reside in memory only for the duration of the connection session). This minimizes the risk of sensitive data exposure.

## Important Security Reminders

*   **Always use HTTPS:** For any production deployment, ensure that all communication between your frontend (web browser) and backend server is encrypted using HTTPS. This prevents interception of sensitive credentials (passwords, private key content) during their initial transmission.
*   **Secure Your Backend Server:** The security of your backend server is paramount. If the backend is compromised, an attacker could potentially gain access to active SSH sessions or generated private keys. Implement strong server hardening measures, including firewalls, intrusion detection, and regular security updates.
*   **Use Strong Passphrases:** If you set a passphrase for your private keys, ensure it's strong and unique. This provides an additional layer of protection if your private key file is ever compromised.
*   **Least Privilege:** Configure the SSH user on the remote server with the minimum necessary privileges. Use `sudo` for commands requiring elevated permissions, and configure passwordless `sudo` if possible to avoid transmitting the `sudo` password repeatedly.

By understanding and utilizing these secure SSH authentication methods, you can ensure that your remote Lynis and OpenSCAP operations are performed with the highest level of security. 